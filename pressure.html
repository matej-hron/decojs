<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pressure & Partial Pressure - Deco Theory</title>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    
    <!-- KaTeX for math formulas -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <!-- App styles -->
    <link rel="stylesheet" href="css/styles.css?v=5">
</head>
<body>
    <!-- Navigation -->
    <nav class="main-nav">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">ü´ß Deco Theory</a>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="dive-setup.html">Dive Setup</a></li>
                <li><a href="pressure.html" class="active">Pressure</a></li>
                <li><a href="tissue-loading.html">Tissue Loading</a></li>
                <li class="nav-dropdown">
                    <a>Tests</a>
                    <ul class="nav-dropdown-menu">
                        <li><a href="quiz-physics.html">Physics</a></li>
                        <li><a href="quiz-anatomy.html">Anatomy</a></li>
                    </ul>
                </li>
                <li><a href="about.html">About</a></li>
            </ul>
            <span class="nav-wip-badge">üß™ Experimental</span>
        </div>
    </nav>

    <!-- Dive Profile Header Bar (Sticky) -->
    <div class="profile-header-bar sticky">
        <div class="profile-header-content">
            <div class="profile-header-info">
                <span class="profile-header-label">Profile:</span>
                <select id="profile-switcher" class="profile-switcher">
                    <!-- Options populated by JavaScript -->
                </select>
                <span id="profile-header-summary" class="profile-header-summary"></span>
            </div>
            <div class="profile-header-actions">
                <a href="dive-setup.html" class="btn btn-small">‚úèÔ∏è Customize</a>
            </div>
        </div>
    </div>

    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner">
        ‚ö†Ô∏è <strong>Educational Use Only</strong> ‚Äî This tool is NOT intended for real dive planning. 
        Never use this for actual dives. Always use certified dive computers, tables, and proper training.
    </div>

    <header>
        <h1>üìä Pressure & Partial Pressure</h1>
        <p class="subtitle">Understanding how pressure changes with depth and affects the gases you breathe</p>
    </header>

    <main>
        <!-- Educational Section -->
        <section class="education-section">
            <h2>üìö Dive Profile Terminology</h2>
            
            <div class="concept-card">
                <h3>Reading a Dive Profile</h3>
                <p>
                    A <strong>dive profile</strong> is a graphical representation of your dive, showing depth over time.
                    Understanding the basic terminology helps you communicate with other divers and interpret 
                    dive computer data effectively.
                </p>
            </div>
        </section>

        <!-- Dive Profile Chart -->
        <section class="chart-section">
            <h2>üìà Your Dive Profile</h2>
            <div class="chart-container" style="height: 450px; position: relative;">
                <canvas id="profile-chart"></canvas>
            </div>
            
            <!-- Terminology Legend -->
            <div class="terminology-legend">
                <h3>üìñ Key Terms</h3>
                <div class="term-grid">
                    <div class="term-item">
                        <span class="term-marker descent"></span>
                        <div class="term-content">
                            <strong>Descent</strong>
                            <span>The phase from leaving the surface until reaching your planned depth. Recommended rate: ‚â§18-20 m/min.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker bottom-time"></span>
                        <div class="term-content">
                            <strong>Bottom Time</strong>
                            <span>Total time from beginning of descent to start of final ascent. Includes descent phase.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker max-depth"></span>
                        <div class="term-content">
                            <strong>Maximum Depth</strong>
                            <span>The deepest point reached during the dive. Determines ambient pressure and gas absorption rate.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker ascent"></span>
                        <div class="term-content">
                            <strong>Ascent</strong>
                            <span>Return to surface. Rate should not exceed 9-10 m/min to prevent bubble formation.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker deco-stop"></span>
                        <div class="term-content">
                            <strong>Deco Stop</strong>
                            <span>Mandatory pause at specific depth during ascent to allow safe elimination of inert gases.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker safety-stop"></span>
                        <div class="term-content">
                            <strong>Safety Stop</strong>
                            <span>Voluntary 3-minute pause at 3-5m during ascent to allow excess nitrogen to off-gas safely.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker surface-interval"></span>
                        <div class="term-content">
                            <strong>Surface Interval (SI)</strong>
                            <span>Time spent at surface between dives to off-gas nitrogen. Longer SI = more nitrogen eliminated.</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>Educational visualization only. Not for dive planning.</p>
    </footer>

    <script type="module">
        import { loadDiveSetup, getDiveSetupWaypoints, saveDiveSetup, clearCache } from './js/diveSetup.js';
        
        // State
        let profileChart = null;
        let currentSetup = null;
        let availableProfiles = [];
        
        // DOM elements
        const profileSwitcher = document.getElementById('profile-switcher');
        const profileHeaderSummary = document.getElementById('profile-header-summary');
        
        // Load and render the dive profile
        async function init() {
            // Load available profiles
            await loadAvailableProfiles();
            
            // Load current setup
            currentSetup = await loadDiveSetup();
            if (!currentSetup) {
                document.getElementById('dive-stats').innerHTML = '<p class="error">Failed to load dive setup</p>';
                return;
            }
            
            // Initialize profile switcher
            initProfileSwitcher();
            
            // Render everything
            render();
            
            // Render KaTeX formulas
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false }
                    ]
                });
            }
        }
        
        async function loadAvailableProfiles() {
            try {
                const response = await fetch('data/dive-profiles.json');
                if (!response.ok) throw new Error(`Failed to load profiles: ${response.status}`);
                const data = await response.json();
                availableProfiles = data.profiles || [];
            } catch (error) {
                console.error('Error loading dive profiles:', error);
                availableProfiles = [];
            }
        }
        
        function initProfileSwitcher() {
            if (!profileSwitcher) return;
            
            // Clear existing options
            profileSwitcher.innerHTML = '';
            
            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = '‚úèÔ∏è Custom Profile';
            profileSwitcher.appendChild(customOption);
            
            // Add separator
            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
            profileSwitcher.appendChild(separator);
            
            // Add predefined profiles
            availableProfiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                option.textContent = profile.name;
                profileSwitcher.appendChild(option);
            });
            
            // Set current selection
            const matchingProfile = availableProfiles.find(p => p.id === currentSetup.id);
            profileSwitcher.value = matchingProfile ? currentSetup.id : 'custom';
            
            // Handle profile switching
            profileSwitcher.addEventListener('change', handleProfileSwitch);
        }
        
        async function handleProfileSwitch(event) {
            const selectedId = event.target.value;
            
            if (selectedId === 'custom') {
                window.location.href = 'dive-setup.html';
                return;
            }
            
            const profile = availableProfiles.find(p => p.id === selectedId);
            if (!profile) return;
            
            currentSetup = profile;
            saveDiveSetup(profile);
            clearCache();
            
            render();
        }
        
        function render() {
            updateProfileHeader();
            renderProfileChart();
        }
        
        function updateProfileHeader() {
            if (!profileHeaderSummary || !currentSetup) return;
            
            const waypoints = getDiveSetupWaypoints(currentSetup);
            const maxDepth = waypoints.length > 0 ? Math.max(...waypoints.map(w => w.depth)) : 0;
            const totalTime = waypoints.length > 0 ? waypoints[waypoints.length - 1].time : 0;
            const gasMix = currentSetup.gasMix?.name || 'Air';
            
            profileHeaderSummary.textContent = `${maxDepth}m / ${totalTime} min on ${gasMix}`;
            
            // Update switcher selection
            if (profileSwitcher) {
                const matchingProfile = availableProfiles.find(p => p.id === currentSetup.id);
                profileSwitcher.value = matchingProfile ? currentSetup.id : 'custom';
            }
        }
        
        function renderProfileChart() {
            const canvas = document.getElementById('profile-chart');
            const ctx = canvas.getContext('2d');
            const waypoints = getDiveSetupWaypoints(currentSetup);
            
            if (waypoints.length === 0) {
                return;
            }
            
            // Check if this is a multi-dive profile
            const isMultiDive = currentSetup.dives && currentSetup.dives.length > 1;
            
            // Calculate key metrics
            const maxDepth = Math.max(...waypoints.map(w => w.depth));
            const totalTime = waypoints[waypoints.length - 1].time;
            
            // Find surface intervals (periods at depth 0 between dives)
            const surfaceIntervals = [];
            let inSurfaceInterval = false;
            let intervalStart = null;
            
            for (let i = 0; i < waypoints.length; i++) {
                const wp = waypoints[i];
                if (wp.depth === 0) {
                    if (!inSurfaceInterval && i > 0) {
                        // Starting a potential surface interval
                        inSurfaceInterval = true;
                        intervalStart = wp.time;
                    }
                } else {
                    if (inSurfaceInterval && intervalStart !== null) {
                        // Ending a surface interval - only count if there's actual time at surface
                        const prevWp = waypoints[i - 1];
                        if (prevWp && prevWp.depth === 0 && prevWp.time > intervalStart) {
                            surfaceIntervals.push({
                                start: intervalStart,
                                end: prevWp.time,
                                duration: prevWp.time - intervalStart
                            });
                        }
                    }
                    inSurfaceInterval = false;
                    intervalStart = null;
                }
            }
            
            // For single dive, add surface interval after dive ends (using setup's surfaceInterval)
            const singleDiveSurfaceInterval = !isMultiDive && currentSetup.surfaceInterval ? currentSetup.surfaceInterval : null;
            
            // For multi-dive profiles, find the end of the first dive (first time we return to surface after going deep)
            let firstDiveEndTime = totalTime;
            if (isMultiDive) {
                // Find first return to surface after leaving it
                let leftSurface = false;
                for (let i = 0; i < waypoints.length; i++) {
                    if (waypoints[i].depth > 0) {
                        leftSurface = true;
                    } else if (leftSurface && waypoints[i].depth === 0) {
                        firstDiveEndTime = waypoints[i].time;
                        break;
                    }
                }
            }
            
            // Find max depth of first dive only
            let firstDiveMaxDepth = 0;
            for (let i = 0; i < waypoints.length; i++) {
                if (waypoints[i].time <= firstDiveEndTime) {
                    firstDiveMaxDepth = Math.max(firstDiveMaxDepth, waypoints[i].depth);
                }
            }
            
            // For annotations, use first dive's max depth for multi-dive, or overall for single dive
            const annotationMaxDepth = isMultiDive ? firstDiveMaxDepth : maxDepth;
            
            // Find descent end (first waypoint at annotation max depth within first dive)
            let descentEnd = null;
            for (let i = 0; i < waypoints.length; i++) {
                if (waypoints[i].depth === annotationMaxDepth && waypoints[i].time <= firstDiveEndTime) {
                    descentEnd = waypoints[i];
                    break;
                }
            }
            
            // Find bottom end / ascent start (last waypoint at annotation max depth within first dive)
            let bottomEnd = null;
            for (let i = waypoints.length - 1; i >= 0; i--) {
                if (waypoints[i].depth === annotationMaxDepth && waypoints[i].time <= firstDiveEndTime) {
                    bottomEnd = waypoints[i];
                    break;
                }
            }
            
            // Find stops (horizontal segments not at max depth and not at surface) - only for first dive
            const stops = [];
            for (let i = 0; i < waypoints.length - 1; i++) {
                const curr = waypoints[i];
                const next = waypoints[i + 1];
                // Only include stops from first dive
                if (curr.time >= firstDiveEndTime) break;
                
                if (curr.depth > 0 && curr.depth < annotationMaxDepth && next.depth === curr.depth) {
                    const existing = stops.find(s => s.depth === curr.depth && s.end.time === curr.time);
                    if (existing) {
                        existing.end = next;
                    } else {
                        stops.push({ start: curr, end: next, depth: curr.depth });
                    }
                }
            }
            
            // Prepare chart data
            const data = {
                datasets: [{
                    label: 'Depth',
                    data: waypoints.map(w => ({ x: w.time, y: w.depth })),
                    borderColor: '#2980b9',
                    backgroundColor: 'rgba(41, 128, 185, 0.15)',
                    fill: true,
                    tension: 0,
                    pointRadius: 4,
                    pointBackgroundColor: '#2980b9',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    borderWidth: 3
                }]
            };
            
            // Build annotations - positioned to avoid collisions
            const annotations = {};
            
            // Descent label - position at top-left of descent line
            if (descentEnd && descentEnd.time > 0) {
                annotations.descentLabel = {
                    type: 'label',
                    xValue: 0.5,
                    yValue: -5,
                    content: ['DESCENT ‚¨á'],
                    backgroundColor: 'rgba(46, 204, 113, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Bottom time bracket - show as bracket at top spanning the bottom time period
            if (bottomEnd) {
                const bottomTimeValue = bottomEnd.time;
                annotations.bottomTimeBracket = {
                    type: 'line',
                    xMin: 0,
                    xMax: bottomEnd.time,
                    yMin: -4,
                    yMax: -4,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3,
                    label: {
                        display: true,
                        content: `BOTTOM TIME: ${bottomTimeValue} min`,
                        position: 'center',
                        backgroundColor: 'rgba(241, 196, 15, 0.95)',
                        color: '#333',
                        font: { size: 10, weight: 'bold' },
                        padding: { top: 3, bottom: 3, left: 6, right: 6 },
                        yAdjust: -12
                    }
                };
                // Left bracket cap
                annotations.bottomTimeCapLeft = {
                    type: 'line',
                    xMin: 0,
                    xMax: 0,
                    yMin: -6,
                    yMax: -2,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3
                };
                // Right bracket cap
                annotations.bottomTimeCapRight = {
                    type: 'line',
                    xMin: bottomEnd.time,
                    xMax: bottomEnd.time,
                    yMin: -6,
                    yMax: -2,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3
                };
            }
            
            // Max depth line - label on the right side
            annotations.maxDepthLine = {
                type: 'line',
                yMin: maxDepth,
                yMax: maxDepth,
                borderColor: 'rgba(231, 76, 60, 0.6)',
                borderWidth: 2,
                borderDash: [6, 4],
                label: {
                    display: true,
                    content: `MAX: ${maxDepth}m`,
                    position: 'end',
                    backgroundColor: 'rgba(231, 76, 60, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                }
            };
            
            // Ascent label - positioned for first dive only
            if (bottomEnd) {
                // Position ascent label near end of first dive's ascent
                const ascentLabelTime = isMultiDive ? firstDiveEndTime - 1 : totalTime - 1;
                
                annotations.ascentLabel = {
                    type: 'label',
                    xValue: ascentLabelTime,
                    yValue: -5,
                    content: ['‚¨Ü ASCENT'],
                    backgroundColor: 'rgba(155, 89, 182, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Stop annotations - labels positioned outside the boxes
            // Determine if this is multi-stage deco (multiple stops = clearly deco)
            const isMultiStageDeco = stops.length > 1;
            
            stops.forEach((stop, i) => {
                const isDeepStop = stop.depth > 5;
                // If multi-stage deco, all stops are clearly deco stops
                // If single stop at shallow depth, it could be safety or deco
                let label;
                if (isDeepStop) {
                    label = 'DECO';
                } else if (isMultiStageDeco) {
                    label = 'DECO';  // Multi-stage means it's clearly a deco dive
                } else {
                    label = 'SAFETY/DECO';  // Single shallow stop - could be either
                }
                const color = isDeepStop ? 'rgba(230, 126, 34, 0.9)' : 'rgba(52, 152, 219, 0.9)';
                const bgColor = isDeepStop ? 'rgba(230, 126, 34, 0.25)' : 'rgba(52, 152, 219, 0.25)';
                const boxPadding = Math.max(1.5, maxDepth * 0.04);
                
                // Draw the stop box
                annotations[`stop${i}`] = {
                    type: 'box',
                    xMin: stop.start.time,
                    xMax: stop.end.time,
                    yMin: stop.depth - boxPadding,
                    yMax: stop.depth + boxPadding,
                    backgroundColor: bgColor,
                    borderColor: color,
                    borderWidth: 2
                };
                
                // Label positioned to the right of the box
                annotations[`stopLabel${i}`] = {
                    type: 'label',
                    xValue: stop.end.time + 0.5,
                    yValue: stop.depth,
                    content: [`${label} ${stop.depth}m`],
                    backgroundColor: color,
                    color: 'white',
                    font: { size: 9, weight: 'bold' },
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                };
            });
            
            // Surface intervals for multi-dive profiles
            surfaceIntervals.forEach((si, i) => {
                if (si.duration > 0) {
                    // Draw surface interval box
                    annotations[`surfaceInterval${i}`] = {
                        type: 'box',
                        xMin: si.start,
                        xMax: si.end,
                        yMin: -8,
                        yMax: 2,
                        backgroundColor: 'rgba(52, 152, 219, 0.15)',
                        borderColor: 'rgba(52, 152, 219, 0.6)',
                        borderWidth: 2,
                        borderDash: [4, 4]
                    };
                    
                    // Surface interval label
                    annotations[`surfaceIntervalLabel${i}`] = {
                        type: 'label',
                        xValue: (si.start + si.end) / 2,
                        yValue: -3,
                        content: [`‚è∏ SI: ${si.duration} min`],
                        backgroundColor: 'rgba(52, 152, 219, 0.9)',
                        color: 'white',
                        font: { size: 10, weight: 'bold' },
                        padding: { top: 3, bottom: 3, left: 6, right: 6 }
                    };
                }
            });
            
            // For single dive, show surface interval indicator on the right (without specific time)
            if (!isMultiDive) {
                const diveEndTime = totalTime;
                // Draw a bracket/line indicating surface interval
                annotations.singleDiveSILine = {
                    type: 'line',
                    xMin: diveEndTime,
                    xMax: diveEndTime + 8,
                    yMin: 0,
                    yMax: 0,
                    borderColor: 'rgba(52, 152, 219, 0.8)',
                    borderWidth: 2,
                    borderDash: [4, 4]
                };
                annotations.singleDiveSI = {
                    type: 'label',
                    xValue: diveEndTime + 4,
                    yValue: -3,
                    content: ['‚è∏ SURFACE INTERVAL'],
                    backgroundColor: 'rgba(52, 152, 219, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Surface reference - positioned in middle
            annotations.surfaceLabel = {
                type: 'label',
                xValue: totalTime * 0.4,
                yValue: 1.5,
                content: ['SURFACE (1 bar)'],
                backgroundColor: 'rgba(100, 100, 100, 0.7)',
                color: 'white',
                font: { size: 9 },
                padding: { top: 2, bottom: 2, left: 4, right: 4 }
            };
            
            // Calculate chart x-axis max to accommodate SI label
            let xAxisMax = Math.ceil(totalTime * 1.15);
            if (!isMultiDive) {
                xAxisMax = Math.max(xAxisMax, totalTime + 15); // Ensure room for SI label
            }
            
            // Chart configuration
            const config = {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (minutes)',
                                font: { size: 14, weight: 'bold' }
                            },
                            min: -1,
                            max: xAxisMax,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: {
                            reverse: true,
                            title: {
                                display: true,
                                text: 'Depth (meters)',
                                font: { size: 14, weight: 'bold' }
                            },
                            min: -10,
                            max: Math.ceil(maxDepth * 1.12),
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: currentSetup.name || 'Dive Profile',
                            font: { size: 16, weight: 'bold' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const depth = context.parsed.y;
                                    const pressure = (1 + depth / 10).toFixed(2);
                                    return [
                                        `Depth: ${depth}m`,
                                        `Ambient: ${pressure} bar`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    }
                }
            };
            
            // Destroy existing chart if any
            if (profileChart) {
                profileChart.destroy();
            }
            
            profileChart = new Chart(ctx, config);
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
