<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pressure & Partial Pressure - Deco Theory</title>
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2980b9">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Deco Theory">
    <link rel="apple-touch-icon" href="icons/icon.svg">
    <link rel="icon" type="image/svg+xml" href="icons/icon.svg">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    
    <!-- KaTeX for math formulas -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <!-- App styles -->
    <link rel="stylesheet" href="css/styles.css?v=6">
</head>
<body>
    <!-- Navigation -->
    <nav class="main-nav">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">ü´ß Deco Theory</a>
            <button class="nav-hamburger" aria-label="Toggle menu" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-links">
                <!-- Generated by js/nav.js -->
            </ul>
            <span class="nav-wip-badge">üß™ Experimental</span>
        </div>
    </nav>

    <!-- Dive Profile Header Bar (Sticky) -->
    <div class="profile-header-bar sticky">
        <div class="profile-header-content">
            <div class="profile-header-info">
                <span class="profile-header-label">Profile:</span>
                <select id="profile-switcher" class="profile-switcher">
                    <!-- Options populated by JavaScript -->
                </select>
                <span id="profile-header-summary" class="profile-header-summary"></span>
            </div>
            <div class="profile-header-actions">
                <a href="dive-setup.html" class="btn btn-small">‚úèÔ∏è Customize</a>
            </div>
        </div>
    </div>

    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner">
        ‚ö†Ô∏è <strong>Educational Use Only</strong> ‚Äî This tool is NOT intended for real dive planning. 
        Never use this for actual dives. Always use certified dive computers, tables, and proper training.
    </div>

    <header>
        <h1>üìä Pressure & Partial Pressure</h1>
        <p class="subtitle">Understanding how pressure changes with depth and affects the gases you breathe</p>
    </header>

    <main>
        <!-- Table of Contents -->
        <nav class="toc">
            <h2>üìë Contents</h2>
            <ul>
                <li><a href="#terminology">üìö Dive Profile Terminology</a></li>
                <li><a href="#dive-profile">üìà Your Dive Profile</a></li>
                <li><a href="#total-pressure">üåä Total Pressure Underwater</a></li>
                <li><a href="#gas-consumption">‚õΩ Gas Consumption</a></li>
            </ul>
        </nav>

        <!-- Educational Section -->
        <section id="terminology" class="education-section">
            <h2>üìö Dive Profile Terminology</h2>
            
            <div class="concept-card">
                <h3>Reading a Dive Profile</h3>
                <p>
                    A <strong>dive profile</strong> is a graphical representation of your dive, showing depth over time.
                    Understanding the basic terminology helps you communicate with other divers and interpret 
                    dive computer data effectively.
                </p>
            </div>
        </section>

        <!-- Dive Profile Chart -->
        <section id="dive-profile" class="chart-section">
            <div class="chart-header">
                <h2>üìà Your Dive Profile</h2>
                <button id="fullscreen-btn" class="btn btn-small btn-icon" title="Fullscreen">
                    <span class="fullscreen-icon">‚õ∂</span>
                    <span class="fullscreen-text">Fullscreen</span>
                </button>
            </div>
            <div class="chart-container" id="chart-container">
                <canvas id="profile-chart"></canvas>
                <button id="exit-fullscreen-btn" class="btn btn-fullscreen-close" title="Exit Fullscreen">‚úï</button>
            </div>
            
            <!-- Terminology Legend -->
            <div class="terminology-legend">
                <h3>üìñ Key Terms</h3>
                <div class="term-grid">
                    <div class="term-item">
                        <span class="term-marker descent"></span>
                        <div class="term-content">
                            <strong>Descent</strong>
                            <span>The phase from leaving the surface until reaching your planned depth. Recommended rate: ‚â§18-20 m/min.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker bottom-time"></span>
                        <div class="term-content">
                            <strong>Bottom Time</strong>
                            <span>Total time from beginning of descent to start of final ascent. Includes descent phase.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker max-depth"></span>
                        <div class="term-content">
                            <strong>Maximum Depth</strong>
                            <span>The deepest point reached during the dive. Determines ambient pressure and gas absorption rate.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker ascent"></span>
                        <div class="term-content">
                            <strong>Ascent</strong>
                            <span>Return to surface. Rate should not exceed 9-10 m/min to prevent bubble formation.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker deco-stop"></span>
                        <div class="term-content">
                            <strong>Deco Stop</strong>
                            <span>Mandatory pause at specific depth during ascent to allow safe elimination of inert gases.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker safety-stop"></span>
                        <div class="term-content">
                            <strong>Safety Stop</strong>
                            <span>Voluntary 3-minute pause at 3-5m during ascent to allow excess nitrogen to off-gas safely.</span>
                        </div>
                    </div>
                    <div class="term-item">
                        <span class="term-marker surface-interval"></span>
                        <div class="term-content">
                            <strong>Surface Interval (SI)</strong>
                            <span>Time spent at surface between dives to off-gas nitrogen. Longer SI = more nitrogen eliminated.</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Total Pressure Section -->
        <section id="total-pressure" class="education-section">
            <h2>üåä Total Pressure Underwater</h2>
            
            <div class="concept-card">
                <h3>What Creates Pressure Underwater?</h3>
                <p>
                    The total pressure a diver experiences underwater comes from two sources:
                </p>
                <ul>
                    <li><strong>Atmospheric pressure</strong> ‚Äî The weight of the air column above you. At sea level, this is approximately <strong>1 bar</strong> (1 atm = 1.01325 bar).</li>
                    <li><strong>Hydrostatic pressure</strong> ‚Äî The weight of the water column above you. In seawater, this adds approximately <strong>1 bar per 10 meters</strong> of depth.</li>
                </ul>
                <p>
                    Therefore, at 10m depth you experience 2 bar total pressure (1 atm + 1 bar water), 
                    at 20m it's 3 bar, at 30m it's 4 bar, and so on.
                </p>
            </div>

            <details class="learn-more">
                <summary>üìç Atmospheric Pressure at Different Altitudes</summary>
                <div class="math-content">
                    <p>Atmospheric pressure decreases with altitude. If you dive in a mountain lake, you start with less than 1 bar at the surface:</p>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Altitude</th>
                                <th>Pressure (bar)</th>
                                <th>Example Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sea level</td>
                                <td>1.013</td>
                                <td>Ocean, coastal lakes</td>
                            </tr>
                            <tr>
                                <td>300 m</td>
                                <td>0.977</td>
                                <td>Low hills</td>
                            </tr>
                            <tr>
                                <td>700 m</td>
                                <td>0.932</td>
                                <td>Mountain lakes</td>
                            </tr>
                            <tr>
                                <td>1500 m</td>
                                <td>0.845</td>
                                <td>High altitude lakes</td>
                            </tr>
                            <tr>
                                <td>2500 m</td>
                                <td>0.747</td>
                                <td>Lake Titicaca</td>
                            </tr>
                            <tr>
                                <td>3000 m</td>
                                <td>0.701</td>
                                <td>Extreme altitude diving</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="note">‚ö†Ô∏è Altitude diving requires special procedures and decompression adjustments.</p>
                </div>
            </details>

            <details class="learn-more">
                <summary>üî¨ Mathematical Formulas</summary>
                <div class="math-content">
                    <h4>Total Ambient Pressure</h4>
                    <p>The total pressure at any depth is the sum of atmospheric and hydrostatic pressure:</p>
                    <div class="formula" id="formula-total-pressure">
                        P_{amb} = P_{atm} + P_{hydro} = P_{atm} + \rho \cdot g \cdot h
                    </div>
                    <p>Where:</p>
                    <ul>
                        <li><span class="formula-inline">P_{amb}</span> = total ambient pressure</li>
                        <li><span class="formula-inline">P_{atm}</span> = atmospheric pressure (‚âà1 bar at sea level)</li>
                        <li><span class="formula-inline">\rho</span> = water density (‚âà1025 kg/m¬≥ for seawater)</li>
                        <li><span class="formula-inline">g</span> = gravitational acceleration (9.81 m/s¬≤)</li>
                        <li><span class="formula-inline">h</span> = depth in meters</li>
                    </ul>

                    <h4>Simplified Formula (Sea Level)</h4>
                    <p>For diving at sea level, we use the simplified formula:</p>
                    <div class="formula" id="formula-simplified-pressure">
                        P_{amb} = 1 + \frac{depth}{10} \text{ bar}
                    </div>
                    <p>This approximation works well for recreational diving calculations.</p>

                    <h4>Atmospheric Pressure vs Altitude</h4>
                    <p>Atmospheric pressure decreases exponentially with altitude:</p>
                    <div class="formula" id="formula-altitude-pressure">
                        P_{atm}(h) = P_0 \cdot e^{-\frac{h}{H}}
                    </div>
                    <p>Where:</p>
                    <ul>
                        <li><span class="formula-inline">P_0</span> = 1.01325 bar (sea level pressure)</li>
                        <li><span class="formula-inline">h</span> = altitude in meters</li>
                        <li><span class="formula-inline">H</span> ‚âà 8500 m (scale height of atmosphere)</li>
                    </ul>
                </div>
            </details>
        </section>

        <!-- Total Pressure Chart Section -->
        <section id="pressure-chart" class="chart-section">
            <div class="chart-header">
                <h2>üìà Dive Profile with Total Pressure</h2>
                <button id="pressure-fullscreen-btn" class="btn btn-small btn-icon" title="Fullscreen">
                    <span class="fullscreen-icon">‚õ∂</span>
                    <span class="fullscreen-text">Fullscreen</span>
                </button>
            </div>
            <div class="chart-container" id="pressure-chart-container">
                <canvas id="total-pressure-chart"></canvas>
                <button id="pressure-exit-fullscreen-btn" class="btn btn-fullscreen-close" title="Exit Fullscreen">‚úï</button>
            </div>
        </section>

        <!-- Gas Consumption Section -->
        <section id="gas-consumption" class="education-section">
            <h2>‚õΩ Gas Consumption</h2>
            
            <div class="concept-card">
                <h3>Why Depth Matters for Gas Supply</h3>
                <p>
                    According to <strong>Boyle-Mariotte's Law</strong>, as pressure increases, the volume of gas decreases proportionally. 
                    Underwater, this means you breathe <em>compressed</em> air from your tank. At 10m depth (2 bar), 
                    each breath draws twice the amount of gas molecules compared to the surface.
                </p>
                <p>
                    This is why deeper dives consume your gas supply faster‚Äîyou're breathing the same volume of air, 
                    but it contains more gas molecules due to compression.
                </p>
            </div>

            <div class="concept-card">
                <h3>Surface Air Consumption (SAC)</h3>
                <p>
                    <strong>SAC rate</strong> (also called RMV - Respiratory Minute Volume) is how much gas you breathe 
                    per minute at the surface. For planning purposes, we use a typical value of <strong>20 L/min</strong> 
                    for relaxed diving, though actual consumption varies based on exertion, stress, and individual factors.
                </p>
                <p>
                    At depth, your actual consumption is: <strong>SAC √ó Ambient Pressure</strong>
                </p>
                <ul>
                    <li>Surface (1 bar): 20 L/min</li>
                    <li>10m (2 bar): 40 L/min</li>
                    <li>20m (3 bar): 60 L/min</li>
                    <li>30m (4 bar): 80 L/min</li>
                    <li>40m (5 bar): 100 L/min</li>
                </ul>
            </div>

            <details class="learn-more">
                <summary>üî¨ Gas Consumption Formula</summary>
                <div class="math-content">
                    <h4>Gas Consumed at Depth</h4>
                    <p>The gas consumption at any depth can be calculated as:</p>
                    <div class="formula" id="formula-gas-consumption">
                        \text{Consumption} = SAC \times P_{amb} \times t
                    </div>
                    <p>Where:</p>
                    <ul>
                        <li><span class="formula-inline">SAC</span> = Surface Air Consumption (L/min at surface)</li>
                        <li><span class="formula-inline">P_{amb}</span> = Ambient pressure in bar (1 + depth/10)</li>
                        <li><span class="formula-inline">t</span> = Time at depth (minutes)</li>
                    </ul>

                    <h4>Available Gas in Cylinder</h4>
                    <div class="formula" id="formula-gas-available">
                        \text{Gas Available} = V_{cylinder} \times (P_{start} - P_{reserve})
                    </div>
                    <p>For a 12L cylinder at 200 bar with 50 bar reserve:</p>
                    <p>Available gas = 12 √ó (200 - 50) = <strong>1800 liters</strong></p>
                </div>
            </details>
        </section>

        <!-- Gas Consumption Chart Section -->
        <section id="gas-consumption-chart" class="chart-section">
            <div class="chart-header">
                <h2>üìà Gas Consumption During Dive</h2>
                <button id="gas-fullscreen-btn" class="btn btn-small btn-icon" title="Fullscreen">
                    <span class="fullscreen-icon">‚õ∂</span>
                    <span class="fullscreen-text">Fullscreen</span>
                </button>
            </div>
            
            <!-- Local Overrides -->
            <div class="chart-controls">
                <div class="control-group">
                    <label for="gas-cylinder-select">Cylinder:</label>
                    <select id="gas-cylinder-select" class="form-select">
                        <option value="10">10 L</option>
                        <option value="12">12 L</option>
                        <option value="15">15 L</option>
                        <option value="18">18 L</option>
                        <option value="14">2√ó7 L (14 L)</option>
                        <option value="20">2√ó10 L (20 L)</option>
                        <option value="24">2√ó12 L (24 L)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="gas-sac-input">SAC Rate (L/min):</label>
                    <input type="number" id="gas-sac-input" class="form-input" value="20" min="10" max="40" step="1">
                </div>
                <div class="control-group">
                    <label for="gas-start-pressure">Start Pressure (bar):</label>
                    <input type="number" id="gas-start-pressure" class="form-input" value="200" min="100" max="300" step="10">
                </div>
            </div>
            
            <div class="chart-container" id="gas-chart-container">
                <canvas id="gas-consumption-canvas"></canvas>
                <button id="gas-exit-fullscreen-btn" class="btn btn-fullscreen-close" title="Exit Fullscreen">‚úï</button>
            </div>
            
            <!-- Gas Summary -->
            <div id="gas-summary" class="stats-summary">
                <div class="stat-item">
                    <span class="stat-label">Total Gas Used:</span>
                    <span id="total-gas-used" class="stat-value">-- L</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Remaining Pressure:</span>
                    <span id="remaining-pressure" class="stat-value">-- bar</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Status:</span>
                    <span id="gas-status" class="stat-value">--</span>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>Educational visualization only. Not for dive planning.</p>
        <span class="version-number"></span>
    </footer>

    <script type="module">
        import { loadDiveSetup, getDiveSetupWaypoints, saveDiveSetup, clearCache, getCylinderVolume } from './js/diveSetup.js';
        
        // State
        let profileChart = null;
        let currentSetup = null;
        let availableProfiles = [];
        
        // DOM elements
        const profileSwitcher = document.getElementById('profile-switcher');
        const profileHeaderSummary = document.getElementById('profile-header-summary');
        
        // Fullscreen controls
        const chartContainer = document.getElementById('chart-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
        
        /**
         * Toggle fullscreen mode for the chart
         */
        function toggleFullscreen() {
            const isFullscreen = chartContainer.classList.toggle('fullscreen');
            
            // Prevent body scroll when fullscreen
            document.body.style.overflow = isFullscreen ? 'hidden' : '';
            
            // Resize chart to fit new container size
            if (profileChart) {
                setTimeout(() => {
                    profileChart.resize();
                }, 50);
            }
        }
        
        // Setup fullscreen event listeners
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        exitFullscreenBtn.addEventListener('click', toggleFullscreen);
        
        // Exit fullscreen on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && chartContainer.classList.contains('fullscreen')) {
                toggleFullscreen();
            }
        });
        
        // Load and render the dive profile
        async function init() {
            // Load available profiles
            await loadAvailableProfiles();
            
            // Load current setup
            currentSetup = await loadDiveSetup();
            if (!currentSetup) {
                document.getElementById('dive-stats').innerHTML = '<p class="error">Failed to load dive setup</p>';
                return;
            }
            
            // Initialize profile switcher
            initProfileSwitcher();
            
            // Render everything
            render();
            
            // Render KaTeX formulas
            renderMathFormulas();
        }
        
        /**
         * Render math formulas using KaTeX
         */
        function renderMathFormulas() {
            // Render block formulas (.formula class)
            const formulas = document.querySelectorAll('.formula');
            formulas.forEach(el => {
                try {
                    if (typeof katex !== 'undefined') {
                        katex.render(el.textContent, el, { displayMode: true });
                    }
                } catch (e) {
                    console.warn('KaTeX error:', e);
                }
            });
            
            // Render inline formulas (.formula-inline class)
            const inlineFormulas = document.querySelectorAll('.formula-inline');
            inlineFormulas.forEach(el => {
                try {
                    if (typeof katex !== 'undefined') {
                        katex.render(el.textContent, el, { displayMode: false });
                    }
                } catch (e) {
                    console.warn('KaTeX inline error:', e);
                }
            });
        }
        
        async function loadAvailableProfiles() {
            try {
                const response = await fetch('data/dive-profiles.json');
                if (!response.ok) throw new Error(`Failed to load profiles: ${response.status}`);
                const data = await response.json();
                availableProfiles = data.profiles || [];
            } catch (error) {
                console.error('Error loading dive profiles:', error);
                availableProfiles = [];
            }
        }
        
        function initProfileSwitcher() {
            if (!profileSwitcher) return;
            
            // Clear existing options
            profileSwitcher.innerHTML = '';
            
            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = '‚úèÔ∏è Custom Profile';
            profileSwitcher.appendChild(customOption);
            
            // Add separator
            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
            profileSwitcher.appendChild(separator);
            
            // Add predefined profiles
            availableProfiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                option.textContent = profile.name;
                profileSwitcher.appendChild(option);
            });
            
            // Set current selection
            const matchingProfile = availableProfiles.find(p => p.id === currentSetup.id);
            profileSwitcher.value = matchingProfile ? currentSetup.id : 'custom';
            
            // Handle profile switching
            profileSwitcher.addEventListener('change', handleProfileSwitch);
        }
        
        async function handleProfileSwitch(event) {
            const selectedId = event.target.value;
            
            if (selectedId === 'custom') {
                window.location.href = 'dive-setup.html';
                return;
            }
            
            const profile = availableProfiles.find(p => p.id === selectedId);
            if (!profile) return;
            
            currentSetup = profile;
            saveDiveSetup(profile);
            clearCache();
            
            render();
        }
        
        function render() {
            updateProfileHeader();
            renderProfileChart();
            renderPressureChart();
        }
        
        function updateProfileHeader() {
            if (!profileHeaderSummary || !currentSetup) return;
            
            const waypoints = getDiveSetupWaypoints(currentSetup);
            const maxDepth = waypoints.length > 0 ? Math.max(...waypoints.map(w => w.depth)) : 0;
            const totalTime = waypoints.length > 0 ? waypoints[waypoints.length - 1].time : 0;
            const gasMix = currentSetup.gasMix?.name || 'Air';
            
            profileHeaderSummary.textContent = `${maxDepth}m / ${totalTime} min on ${gasMix}`;
            
            // Update switcher selection
            if (profileSwitcher) {
                const matchingProfile = availableProfiles.find(p => p.id === currentSetup.id);
                profileSwitcher.value = matchingProfile ? currentSetup.id : 'custom';
            }
        }
        
        function renderProfileChart() {
            const canvas = document.getElementById('profile-chart');
            const ctx = canvas.getContext('2d');
            const waypoints = getDiveSetupWaypoints(currentSetup);
            
            if (waypoints.length === 0) {
                return;
            }
            
            // Check if this is a multi-dive profile
            const isMultiDive = currentSetup.dives && currentSetup.dives.length > 1;
            
            // Calculate key metrics
            const maxDepth = Math.max(...waypoints.map(w => w.depth));
            const totalTime = waypoints[waypoints.length - 1].time;
            
            // Find surface intervals (periods at depth 0 between dives)
            const surfaceIntervals = [];
            let inSurfaceInterval = false;
            let intervalStart = null;
            
            for (let i = 0; i < waypoints.length; i++) {
                const wp = waypoints[i];
                if (wp.depth === 0) {
                    if (!inSurfaceInterval && i > 0) {
                        // Starting a potential surface interval
                        inSurfaceInterval = true;
                        intervalStart = wp.time;
                    }
                } else {
                    if (inSurfaceInterval && intervalStart !== null) {
                        // Ending a surface interval - only count if there's actual time at surface
                        const prevWp = waypoints[i - 1];
                        if (prevWp && prevWp.depth === 0 && prevWp.time > intervalStart) {
                            surfaceIntervals.push({
                                start: intervalStart,
                                end: prevWp.time,
                                duration: prevWp.time - intervalStart
                            });
                        }
                    }
                    inSurfaceInterval = false;
                    intervalStart = null;
                }
            }
            
            // For single dive, add surface interval after dive ends (using setup's surfaceInterval)
            const singleDiveSurfaceInterval = !isMultiDive && currentSetup.surfaceInterval ? currentSetup.surfaceInterval : null;
            
            // For multi-dive profiles, find the end of the first dive (first time we return to surface after going deep)
            let firstDiveEndTime = totalTime;
            if (isMultiDive) {
                // Find first return to surface after leaving it
                let leftSurface = false;
                for (let i = 0; i < waypoints.length; i++) {
                    if (waypoints[i].depth > 0) {
                        leftSurface = true;
                    } else if (leftSurface && waypoints[i].depth === 0) {
                        firstDiveEndTime = waypoints[i].time;
                        break;
                    }
                }
            }
            
            // Find max depth of first dive only
            let firstDiveMaxDepth = 0;
            for (let i = 0; i < waypoints.length; i++) {
                if (waypoints[i].time <= firstDiveEndTime) {
                    firstDiveMaxDepth = Math.max(firstDiveMaxDepth, waypoints[i].depth);
                }
            }
            
            // For annotations, use first dive's max depth for multi-dive, or overall for single dive
            const annotationMaxDepth = isMultiDive ? firstDiveMaxDepth : maxDepth;
            
            // Find descent end (first waypoint at annotation max depth within first dive)
            let descentEnd = null;
            for (let i = 0; i < waypoints.length; i++) {
                if (waypoints[i].depth === annotationMaxDepth && waypoints[i].time <= firstDiveEndTime) {
                    descentEnd = waypoints[i];
                    break;
                }
            }
            
            // Find bottom end / ascent start (last waypoint at annotation max depth within first dive)
            let bottomEnd = null;
            for (let i = waypoints.length - 1; i >= 0; i--) {
                if (waypoints[i].depth === annotationMaxDepth && waypoints[i].time <= firstDiveEndTime) {
                    bottomEnd = waypoints[i];
                    break;
                }
            }
            
            // Find stops (horizontal segments not at max depth and not at surface) - only for first dive
            const stops = [];
            for (let i = 0; i < waypoints.length - 1; i++) {
                const curr = waypoints[i];
                const next = waypoints[i + 1];
                // Only include stops from first dive
                if (curr.time >= firstDiveEndTime) break;
                
                if (curr.depth > 0 && curr.depth < annotationMaxDepth && next.depth === curr.depth) {
                    const existing = stops.find(s => s.depth === curr.depth && s.end.time === curr.time);
                    if (existing) {
                        existing.end = next;
                    } else {
                        stops.push({ start: curr, end: next, depth: curr.depth });
                    }
                }
            }
            
            // Prepare chart data
            const data = {
                datasets: [{
                    label: 'Depth',
                    data: waypoints.map(w => ({ x: w.time, y: w.depth })),
                    borderColor: '#2980b9',
                    backgroundColor: 'rgba(41, 128, 185, 0.15)',
                    fill: true,
                    tension: 0,
                    pointRadius: 4,
                    pointBackgroundColor: '#2980b9',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    borderWidth: 3
                }]
            };
            
            // Build annotations - positioned to avoid collisions
            const annotations = {};
            
            // Descent label - position at top-left of descent line
            if (descentEnd && descentEnd.time > 0) {
                annotations.descentLabel = {
                    type: 'label',
                    xValue: 0.5,
                    yValue: -5,
                    content: ['DESCENT ‚¨á'],
                    backgroundColor: 'rgba(46, 204, 113, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Bottom time bracket - show as bracket at top spanning the bottom time period
            if (bottomEnd) {
                const bottomTimeValue = bottomEnd.time;
                annotations.bottomTimeBracket = {
                    type: 'line',
                    xMin: 0,
                    xMax: bottomEnd.time,
                    yMin: -4,
                    yMax: -4,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3,
                    label: {
                        display: true,
                        content: `BOTTOM TIME: ${bottomTimeValue} min`,
                        position: 'center',
                        backgroundColor: 'rgba(241, 196, 15, 0.95)',
                        color: '#333',
                        font: { size: 10, weight: 'bold' },
                        padding: { top: 3, bottom: 3, left: 6, right: 6 },
                        yAdjust: -12
                    }
                };
                // Left bracket cap
                annotations.bottomTimeCapLeft = {
                    type: 'line',
                    xMin: 0,
                    xMax: 0,
                    yMin: -6,
                    yMax: -2,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3
                };
                // Right bracket cap
                annotations.bottomTimeCapRight = {
                    type: 'line',
                    xMin: bottomEnd.time,
                    xMax: bottomEnd.time,
                    yMin: -6,
                    yMax: -2,
                    borderColor: 'rgba(241, 196, 15, 0.9)',
                    borderWidth: 3
                };
            }
            
            // Max depth line - label on the right side
            annotations.maxDepthLine = {
                type: 'line',
                yMin: maxDepth,
                yMax: maxDepth,
                borderColor: 'rgba(231, 76, 60, 0.6)',
                borderWidth: 2,
                borderDash: [6, 4],
                label: {
                    display: true,
                    content: `MAX: ${maxDepth}m`,
                    position: 'end',
                    backgroundColor: 'rgba(231, 76, 60, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                }
            };
            
            // Ascent label - positioned for first dive only
            if (bottomEnd) {
                // Position ascent label near end of first dive's ascent
                const ascentLabelTime = isMultiDive ? firstDiveEndTime - 1 : totalTime - 1;
                
                annotations.ascentLabel = {
                    type: 'label',
                    xValue: ascentLabelTime,
                    yValue: -5,
                    content: ['‚¨Ü ASCENT'],
                    backgroundColor: 'rgba(155, 89, 182, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Stop annotations - labels positioned outside the boxes
            // Determine if this is multi-stage deco (multiple stops = clearly deco)
            const isMultiStageDeco = stops.length > 1;
            
            stops.forEach((stop, i) => {
                const isDeepStop = stop.depth > 5;
                // If multi-stage deco, all stops are clearly deco stops
                // If single stop at shallow depth, it could be safety or deco
                let label;
                if (isDeepStop) {
                    label = 'DECO';
                } else if (isMultiStageDeco) {
                    label = 'DECO';  // Multi-stage means it's clearly a deco dive
                } else {
                    label = 'SAFETY/DECO';  // Single shallow stop - could be either
                }
                const color = isDeepStop ? 'rgba(230, 126, 34, 0.9)' : 'rgba(52, 152, 219, 0.9)';
                const bgColor = isDeepStop ? 'rgba(230, 126, 34, 0.25)' : 'rgba(52, 152, 219, 0.25)';
                const boxPadding = Math.max(1.5, maxDepth * 0.04);
                
                // Draw the stop box
                annotations[`stop${i}`] = {
                    type: 'box',
                    xMin: stop.start.time,
                    xMax: stop.end.time,
                    yMin: stop.depth - boxPadding,
                    yMax: stop.depth + boxPadding,
                    backgroundColor: bgColor,
                    borderColor: color,
                    borderWidth: 2
                };
                
                // Label positioned to the right of the box
                annotations[`stopLabel${i}`] = {
                    type: 'label',
                    xValue: stop.end.time + 0.5,
                    yValue: stop.depth,
                    content: [`${label} ${stop.depth}m`],
                    backgroundColor: color,
                    color: 'white',
                    font: { size: 9, weight: 'bold' },
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                };
            });
            
            // Surface intervals for multi-dive profiles
            surfaceIntervals.forEach((si, i) => {
                if (si.duration > 0) {
                    // Draw surface interval box
                    annotations[`surfaceInterval${i}`] = {
                        type: 'box',
                        xMin: si.start,
                        xMax: si.end,
                        yMin: -8,
                        yMax: 2,
                        backgroundColor: 'rgba(52, 152, 219, 0.15)',
                        borderColor: 'rgba(52, 152, 219, 0.6)',
                        borderWidth: 2,
                        borderDash: [4, 4]
                    };
                    
                    // Surface interval label
                    annotations[`surfaceIntervalLabel${i}`] = {
                        type: 'label',
                        xValue: (si.start + si.end) / 2,
                        yValue: -3,
                        content: [`‚è∏ SI: ${si.duration} min`],
                        backgroundColor: 'rgba(52, 152, 219, 0.9)',
                        color: 'white',
                        font: { size: 10, weight: 'bold' },
                        padding: { top: 3, bottom: 3, left: 6, right: 6 }
                    };
                }
            });
            
            // For single dive, show surface interval indicator on the right (without specific time)
            if (!isMultiDive) {
                const diveEndTime = totalTime;
                // Draw a bracket/line indicating surface interval
                annotations.singleDiveSILine = {
                    type: 'line',
                    xMin: diveEndTime,
                    xMax: diveEndTime + 8,
                    yMin: 0,
                    yMax: 0,
                    borderColor: 'rgba(52, 152, 219, 0.8)',
                    borderWidth: 2,
                    borderDash: [4, 4]
                };
                annotations.singleDiveSI = {
                    type: 'label',
                    xValue: diveEndTime + 4,
                    yValue: -3,
                    content: ['‚è∏ SURFACE INTERVAL'],
                    backgroundColor: 'rgba(52, 152, 219, 0.9)',
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    padding: { top: 3, bottom: 3, left: 6, right: 6 }
                };
            }
            
            // Surface reference - positioned in middle
            annotations.surfaceLabel = {
                type: 'label',
                xValue: totalTime * 0.4,
                yValue: 1.5,
                content: ['SURFACE (1 bar)'],
                backgroundColor: 'rgba(100, 100, 100, 0.7)',
                color: 'white',
                font: { size: 9 },
                padding: { top: 2, bottom: 2, left: 4, right: 4 }
            };
            
            // Calculate chart x-axis max to accommodate SI label
            let xAxisMax = Math.ceil(totalTime * 1.15);
            if (!isMultiDive) {
                xAxisMax = Math.max(xAxisMax, totalTime + 15); // Ensure room for SI label
            }
            
            // Chart configuration
            const config = {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (minutes)',
                                font: { size: 14, weight: 'bold' }
                            },
                            min: -1,
                            max: xAxisMax,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: {
                            reverse: true,
                            title: {
                                display: true,
                                text: 'Depth (meters)',
                                font: { size: 14, weight: 'bold' }
                            },
                            min: -10,
                            max: Math.ceil(maxDepth * 1.12),
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: currentSetup.name || 'Dive Profile',
                            font: { size: 16, weight: 'bold' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const depth = context.parsed.y;
                                    const pressure = (1 + depth / 10).toFixed(2);
                                    return [
                                        `Depth: ${depth}m`,
                                        `Ambient: ${pressure} bar`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    }
                }
            };
            
            // Destroy existing chart if any
            if (profileChart) {
                profileChart.destroy();
            }
            
            profileChart = new Chart(ctx, config);
        }
        
        // Total Pressure Chart
        let pressureChart = null;
        const pressureChartContainer = document.getElementById('pressure-chart-container');
        const pressureFullscreenBtn = document.getElementById('pressure-fullscreen-btn');
        const pressureExitFullscreenBtn = document.getElementById('pressure-exit-fullscreen-btn');
        
        function togglePressureFullscreen() {
            const isFullscreen = pressureChartContainer.classList.toggle('fullscreen');
            document.body.style.overflow = isFullscreen ? 'hidden' : '';
            if (pressureChart) {
                setTimeout(() => pressureChart.resize(), 50);
            }
        }
        
        pressureFullscreenBtn?.addEventListener('click', togglePressureFullscreen);
        pressureExitFullscreenBtn?.addEventListener('click', togglePressureFullscreen);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && pressureChartContainer?.classList.contains('fullscreen')) {
                togglePressureFullscreen();
            }
        });
        
        function renderPressureChart() {
            const canvas = document.getElementById('total-pressure-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const waypoints = getDiveSetupWaypoints(currentSetup);
            
            if (waypoints.length === 0) return;
            
            const maxDepth = Math.max(...waypoints.map(w => w.depth));
            const totalTime = waypoints[waypoints.length - 1].time;
            
            // Interpolate to get data points at regular intervals (every 0.5 minutes)
            function interpolateDepth(time) {
                // Find the two waypoints that bracket this time
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const w1 = waypoints[i];
                    const w2 = waypoints[i + 1];
                    if (time >= w1.time && time <= w2.time) {
                        // Linear interpolation
                        const t = (time - w1.time) / (w2.time - w1.time);
                        return w1.depth + t * (w2.depth - w1.depth);
                    }
                }
                // Edge cases
                if (time <= waypoints[0].time) return waypoints[0].depth;
                return waypoints[waypoints.length - 1].depth;
            }
            
            // Generate interpolated data points every 0.5 minutes
            const interpolatedData = [];
            const interval = 0.5; // minutes
            for (let t = 0; t <= totalTime; t += interval) {
                const depth = interpolateDepth(t);
                interpolatedData.push({
                    x: t,
                    y: depth,
                    pressure: 1 + depth / 10
                });
            }
            // Ensure we include the final point
            if (interpolatedData[interpolatedData.length - 1].x < totalTime) {
                const depth = interpolateDepth(totalTime);
                interpolatedData.push({
                    x: totalTime,
                    y: depth,
                    pressure: 1 + depth / 10
                });
            }
            
            // Find key points to annotate with pressure values
            const annotationPoints = [];
            
            // Add surface start
            if (waypoints.length > 0) {
                annotationPoints.push({ time: 0, depth: 0, pressure: 1, label: '1.0 bar' });
            }
            
            // Find max depth point
            const maxDepthWaypoint = waypoints.find(w => w.depth === maxDepth);
            if (maxDepthWaypoint) {
                const pressure = 1 + maxDepth / 10;
                annotationPoints.push({ 
                    time: maxDepthWaypoint.time, 
                    depth: maxDepth, 
                    pressure, 
                    label: `${pressure.toFixed(1)} bar`
                });
            }
            
            // Find any decompression stops (horizontal segments at depth)
            for (let i = 0; i < waypoints.length - 1; i++) {
                const curr = waypoints[i];
                const next = waypoints[i + 1];
                // Horizontal segment (same depth, different time), not at surface or max depth
                if (curr.depth > 0 && curr.depth < maxDepth && curr.depth === next.depth) {
                    const pressure = 1 + curr.depth / 10;
                    // Check if we already have this point
                    const exists = annotationPoints.some(p => p.depth === curr.depth);
                    if (!exists) {
                        annotationPoints.push({
                            time: curr.time,
                            depth: curr.depth,
                            pressure,
                            label: `${pressure.toFixed(1)} bar`
                        });
                    }
                }
            }
            
            // Build annotations for pressure labels
            const annotations = {};
            annotationPoints.forEach((point, index) => {
                annotations[`pressure${index}`] = {
                    type: 'label',
                    xValue: point.time,
                    yValue: point.depth,
                    yScaleID: 'yDepth',
                    content: point.label,
                    backgroundColor: 'rgba(155, 89, 182, 0.9)',
                    color: 'white',
                    font: { size: 11, weight: 'bold' },
                    padding: { top: 4, bottom: 4, left: 8, right: 8 },
                    xAdjust: point.time === 0 ? 30 : 0,
                    yAdjust: point.depth === 0 ? 15 : (point.depth === maxDepth ? -15 : 0)
                };
            });
            
            const maxPressure = 1 + maxDepth / 10;
            
            const data = {
                datasets: [{
                    label: 'Dive Profile (Depth)',
                    data: interpolatedData.map(p => ({ x: p.x, y: p.y })),
                    borderColor: '#2980b9',
                    backgroundColor: 'rgba(41, 128, 185, 0.15)',
                    fill: true,
                    tension: 0,
                    pointRadius: 0,
                    borderWidth: 3,
                    yAxisID: 'yDepth'
                }, {
                    label: 'Total Pressure',
                    data: interpolatedData.map(p => ({ x: p.x, y: p.pressure })),
                    borderColor: '#9b59b6',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0,
                    pointRadius: 0,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    yAxisID: 'yPressure'
                }]
            };
            
            const config = {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (minutes)',
                                font: { size: 14, weight: 'bold' }
                            },
                            min: 0,
                            max: Math.ceil(totalTime * 1.05),
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        yDepth: {
                            type: 'linear',
                            position: 'left',
                            reverse: true,
                            title: {
                                display: true,
                                text: 'Depth (meters)',
                                font: { size: 14, weight: 'bold' },
                                color: '#2980b9'
                            },
                            min: -5,
                            max: Math.ceil(maxDepth * 1.1),
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                color: '#2980b9'
                            }
                        },
                        yPressure: {
                            type: 'linear',
                            position: 'right',
                            reverse: false,
                            title: {
                                display: true,
                                text: 'Pressure (bar)',
                                font: { size: 14, weight: 'bold' },
                                color: '#9b59b6'
                            },
                            min: 1,
                            max: Math.ceil(maxPressure * 1.1),
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                color: '#9b59b6'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    hover: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                padding: 12,
                                font: { size: 12 }
                            },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                
                                // Toggle visibility
                                meta.hidden = !meta.hidden;
                                chart.update();
                            },
                            onHover: (e, legendItem, legend) => {
                                e.native.target.style.cursor = 'pointer';
                            },
                            onLeave: (e, legendItem, legend) => {
                                e.native.target.style.cursor = 'default';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Dive Profile with Total Pressure',
                            font: { size: 16, weight: 'bold' }
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Time: ${items[0].parsed.x.toFixed(1)} min`,
                                label: (context) => {
                                    if (context.dataset.label === 'Dive Profile (Depth)') {
                                        const depth = context.parsed.y;
                                        return `Depth: ${depth.toFixed(1)}m`;
                                    } else {
                                        const pressure = context.parsed.y;
                                        return `Pressure: ${pressure.toFixed(2)} bar`;
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    }
                }
            };
            
            if (pressureChart) {
                pressureChart.destroy();
            }
            
            pressureChart = new Chart(ctx, config);
        }
        
        // Initialize on load
        init();
    </script>
    
    <!-- Shared Navigation -->
    <script src="js/nav.js" type="module"></script>
</body>
</html>
